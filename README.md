# TSwiftQuiz
## Which Taylor Swift album are you? A Quiz in Assembly
#### Chloe Sheen, Taylor Cross, Seher Sethi

### Overview:
Our overall project picture goal is to create a Buzzfeed-style quiz that takes in user input and returns a result based on user’s answer choices. The organization of our project is as follows:
First, we have a set of 6 predefined questions and 6 answer choices for each of the questions. These are displayed to the reader at the start of the program. Then, we ask for the reader’s input (possible input choices are 1-6), which we keep track of. Eventually, we add up all of the user inputs and display the appropriate result with an image. 

### Infrastructure:
This project is unique in that we also grappled with content creation and user experience.
The overall infrastructure can be broken down into five parts. The first is the use of an array to store questions and answer choices. The second is the use of TRAP commands to display questions and answer choices (PUTSP) and ask the user for input (IN). The third is the use of variables to store the user’s answers. The fourth is the use of two functions, ASCIIFUNC and ADDFUNC, to convert the user’s input from ASCII to decimal form and then create a sum (navigating from one function to another is done through JSR and saving R7 in a call stack). The fifth is the use of branches to decide which results to display.

### Code Examples:
The array that stores our questions and answer choices. We have already defined Q1-Q6 and A1-A6 using the directive .STRINGC with corresponding question and answer content. We used .STRINGC instead of .STRINGZ because it allows for a better use of storage due to its ability to store two characters per word of memory. 

When our program is first executed, our goal is to print out the questions and answer choices and ask for user input. We do this by LEA-ing the array into R1. This puts the address of the array into R1, which we then LDR into R0 so that we can use TRAP instruction PUTSP to display the contents of R0. In order to display other questions and answer choices in the array, we increment the address of the start of the array (stored in R1) by 1 and load the incremented address into R0.
 
We continue doing this until we have displayed all of the questions and answers stored in out array. We ask for user input using TRAP x23 (IN) and then store each of the answers into R0. 

ASCIIFUNC, which is a function that converts the input values (stored in ANS1, ANS2, etc.) from ASCII representation into decimal. 
We first LD the 6 ASCII values of the inputs into registers R1-R6, respectively. Then, we LD the variable “ASCII” into R0; we defined ASCII as -48 using the .FILL directive. We do this in order to be able to add the hex value 30 to the user inputs. We did not directly add hex 30 to the registers because of overflow. Then, we ADDed each of the stored values in R1 through R6 with R0, which contains the value -48. This successfully converts ASCII user input into their respective decimal values. 
The function then returns back to the place it jumped from in ADDFUNC, described below.

ADDFUNC, which is a function that sums all of the user inputs and stores the sum into R0. 
The first two lines of the function relate to the call stack which we will explain below. The function takes the results from ASCIIFUNC after ASCIIFUNC is completed and then adds the values in Registers 1-7 to the value in R0. By adding each value to R0, we sum the user’s answer choices. We store the sum in R0 because this is the register that is used with the TRAP functions. This is important to display the final result to the user. 
 
The first image displays our first branch, and the second displays where the code branches to if the previous instruction before the branch created a zero or positive value. Branches are used in our project to display the appropriate result based on the user’s input. We created a range of results that corresponded to one of Taylor Swift’s albums. 
The ranges are as follows:
6-7 = Taylor Swift, 8-13 = Fearless, 14-19 = Speak Now, 20-25 = Red,  26-31 = 1989, and 32-36 = Reputation. 
These ranges were created with the thought that if you answered some questions from her earlier album and some from her later album, then your result should indicate that you are one of the middle albums. We use R3 to compare the sum of the user’s answers to the ranges we created. We first set R3 to be -32 because 32 was the lowest value of the highest range. If the user’s sum was between 32 to 36 then their result is Reputation and the code branched to this part in memory. The result corresponding to our label Reputation is then displayed to the user. If the user’s result was below 32, then the code does not branch and instead moves to the next line in the code. At this step, we add six to reach the lowest value of the next highest range which would be 26. We then add the sum to this value and check if it is zero or positive and continue the process described above. These steps will continue until a branch is executed and a result is displayed. The program halts after a result is displayed or if the code did not branch to any result.  

### Project Difficulty & The Call Stack
To meet the goals of the project, we incorporated various data structures and concepts discussed in class including: arrays, branches, the call stack, subroutines, TRAP routines, some HTML. Our program required immense debugging and managing limitation with memory.
Here is how we used a call stack in our program. 

A Call Stack is used to keep track of R7 in order to return to the appropriate location after each function is completed. In our ADDFUNC function, we store R7 into the variable REG7 before the JSR to PUSH. The variable was loaded into the call stack. 
Within the PUSH, we use R2, R5, R6 as temporary memory holders. We load the TOP of the stack into R6, and then push REG7 onto the stack and increment the TOP of the stack by 1. Then we return back to ADDFUNC. 
Within the POP, we use R5 and R6 as temporary memory holders. We load the TOP of the stack into R6, decrement by 1 to get to the latest value pushed onto the stack. We then store this value into REG7, decrement the top of the stack, and return back to ADDFUNC. Before we RET to our “main” function, we load the value stored in REG7 into R7. 

### Challenges and Limitations:
Aside from the challenges already mentioned, the one we would like to highlight in this section is the use of memory space. We attempted to arrange our code in many different ways in order to get around issues of memory space shortage. Through the presentations of our peers (which also taught us that listening to how other people write their code can be incredibly useful) we discovered that the way to get around this memory limitation was through the use of the LDI instruction. We spent the last couple days of the project working on implementing the LDI instruction in our program. This, however, messed up other parts of our code that relied on the way we had originally written the program. Unfortunately, we ran out of time to properly implement the LDI and as such our program does not display as many HTML images as we had wished. When we continue working on this project, our first step will be to line by line implement the LDI instruction and rework other areas of the code that relied on previous program structure.

### Above and Beyond:
One way that we went above and beyond in this project was the use of the call stack. In order for our program to work, a much simpler, less time consuming solution would have been to save the value of R7 after our first JSR as a variable and then load the value of the variable into R7 before our final “RET”. In order to showcase our knowledge of the stack, we could have added some sort of separate “dummy” stack-related function. 
We, however, really wanted to incorporate the use of the call stack, rather than a variable, to keep track of R7 for two reasons. One, we wanted to ensure that we understood the way the call stack functioned within a more complex program. Two, we felt that a call stack would greatly increase the generality of our program. This is because if someone wanted to expand our program, and needed multiple R7’s saved rather than just one (a.k.a. needed to use many subroutines), our program would be much more useful with the call stack incorporated. The choice to use the call stack within our larger program encouraged us to create multiple flow charts and also required about two additional days of debugging. We stuck with it, however, and thus, believe this is our best example of going above and beyond. 

### Future Ideas and Lessons Learned:
Future Ideas for our project is to make our code more general to support other Buzzfeed style quizzes. Our code is set up for six answer choices as shown in the branches section. We would like to extend this limitation so more answer choices could be added or removed depending on the quiz designer’s preferences. Adding more questions and answers also means monitoring potential memory issues which was a constant problem of this project. Another idea is to add more HTML to make the quiz more appealing to users, such as adding an image after each question and not just in the results section. 
Some key lessons learned from this project is how to manage memory space and structure our program to avoid any memory issues. Another problem we faced was deciding how to compare our sum with the result ranges. We wanted to take the negation of our sum and compare it to the ranges, but when we tried using the NOT instruction, the program confused decimal and binary notation when adding a 1 in binary after NOTing the sum. Since adding a B in front of the number to indicate binary is not an option in Jupyter, we tried writing this whole line of code in machine language, but Jupyter still could not correctly identify the ‘1’ as a binary number. This forced us to change our initial strategy and instead compare a negative range value to a positive sum and branch off a positive or zero number instead of a positive number. An additional lesson learned from this project is how to design a call stack and specifically one that fits our project. Saving all the registers was not important for our project, so removing that piece was our main update to the call stack code that we were provided. We then altered the stack until it saved the variables and registers that we found necessary. Overall, this project helped us gain a better understanding of how to write in assembly language and the main limitations that come with assembly language. Additionally, we were able to implement different data structures and create a user-interactive quiz. 
